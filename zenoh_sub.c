#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <gui/modules/submenu.h>
#include <gui/modules/variable_item_list.h>
#include <gui/modules/widget.h>
#include <gui/view.h>
#include <gui/view_dispatcher.h>
#include <notification/notification.h>
#include <notification/notification_messages.h>

/* generated by fbt from .png files in images folder */
#include <ctype.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <zenoh-pico.h>
#include <zenoh_sub_icons.h>

_z_list_t* g_samples_list = NULL;
zp_mutex_t g_samples_list_mutex = NULL;

typedef struct stored_sample {
    char* key;
    char* val;
} stored_sample_t;

#define TAG "Zenoh"

typedef enum {
    ZenohSubmenuIndexConfigure,
    ZenohSubmenuIndexMonitor,
    ZenohSubmenuIndexAbout,
} ZenohSubmenuIndex;

typedef enum {
    ZenohViewSubmenu,    // The menu when the app starts
    ZenohViewTextInput,  // Input for configuring text settings
    ZenohViewConfigure,  // The configuration screen
    ZenohViewMonitor,    // The main screen
    ZenohViewAbout,      // The about screen with directions, link to social channel, etc.
} ZenohView;

typedef enum {
    ZenohEventIdRedrawScreen = 0,  // Custom event to redraw the screen
    ZenohEventIdOkPressed = 42,    // Custom event to process OK button getting pressed down
} ZenohEventId;

typedef struct {
    ViewDispatcher* view_dispatcher;              // Switches between our views
    Submenu* submenu;                             // The application menu
    VariableItemList* variable_item_list_config;  // The configuration screen
    View* view_game;                              // The main screen
    Widget* widget_about;                         // The about screen

    FuriTimer* timer;  // Timer for redrawing the screen

    z_owned_session_t session;
    z_owned_subscriber_t subscriber;
} ZenohApp;

typedef struct {
    uint32_t baudrate;  // Baudrate setting index
    uint8_t x;          // The x coordinate
} ZenohMonitorModel;

static const char* setting_1_config_label = "Baudrate";
static uint8_t setting_1_values[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
static char* setting_1_names[] = {"4800", "9600", "19200", "38400", "57600", "112500", "230400", "460800", "921600"};

static void zenoh_setting_1_change(VariableItem* item) {
    ZenohApp* app = variable_item_get_context(item);
    uint8_t index = variable_item_get_current_value_index(item);
    variable_item_set_current_value_text(item, setting_1_names[index]);
    ZenohMonitorModel* model = view_get_model(app->view_game);
    model->baudrate = index;
}

void data_handler(const z_sample_t* sample, void* arg) {
    (void)(arg);

    z_owned_str_t keystr = z_keyexpr_to_string(sample->keyexpr);
    FURI_LOG_I(TAG, ">> [Subscriber] Received ('%s': '%.*s')\n", z_str_loan(&keystr), (int)sample->payload.len,
               sample->payload.start);

    stored_sample_t* ss = malloc(sizeof(stored_sample_t));

    ss->key = strdup(z_str_loan(&keystr));
    ss->val = malloc(sample->payload.len + 1);
    strncpy(ss->val, (const char*)sample->payload.start, sample->payload.len);
    ss->val[sample->payload.len] = '\0';

    zp_mutex_lock(&g_samples_list_mutex);
    g_samples_list = _z_list_push_back(g_samples_list, ss);
    if (_z_list_len(g_samples_list) > 5) {
        g_samples_list = _z_list_pop(g_samples_list, _z_noop_elem_free, (void**)&ss);
        free(ss->key);
        free(ss->val);
        free(ss);
    }
    zp_mutex_unlock(&g_samples_list_mutex);

    z_str_drop(z_str_move(&keystr));
}

int zenoh_sub_start(ZenohApp* app) {
    if (z_session_check(&app->session)) {
        return 0;
    }

    ZenohMonitorModel* model = view_get_model(app->view_game);
    const size_t sbuf_size = 100;
    char sconnect[sbuf_size + 1];
    strncpy(sconnect, "serial/usart#baudrate=", sbuf_size);
    strncat(sconnect, setting_1_names[model->baudrate], sbuf_size);

    z_owned_config_t config = z_config_default();

    zp_config_insert(z_loan(config), Z_CONFIG_MODE_KEY, z_string_make("client"));
    zp_config_insert(z_loan(config), Z_CONFIG_CONNECT_KEY, z_string_make(sconnect));
    FURI_LOG_I(TAG, "Opening session...\n");

    app->session = z_open(z_config_move(&config));
    if (!z_session_check(&app->session)) {
        FURI_LOG_E(TAG, "Unable to open session!\n");
        return -1;
    }

    // Start read and lease tasks for zenoh-pico
    if (zp_start_read_task(z_session_loan(&app->session), NULL) < 0 ||
        zp_start_lease_task(z_session_loan(&app->session), NULL) < 0) {
        FURI_LOG_E(TAG, "Unable to start read and lease tasks\n");
        z_close(z_session_move(&app->session));
        return -1;
    }

    const char* keyexpr = "demo/**";
    z_owned_closure_sample_t callback = z_closure_sample(data_handler, NULL, NULL);
    FURI_LOG_I(TAG, "Declaring Subscriber on '%s'...\n", keyexpr);
    app->subscriber =
        z_declare_subscriber(z_session_loan(&app->session), z_keyexpr(keyexpr), z_closure_sample_move(&callback), NULL);
    if (!z_subscriber_check(&app->subscriber)) {
        FURI_LOG_E(TAG, "Unable to declare subscriber.\n");
        z_close(z_session_move(&app->session));
        return -1;
    }

    return 0;
}

int zenoh_sub_stop(ZenohApp* app) {
    if (z_subscriber_check(&app->subscriber)) {
        z_undeclare_subscriber(z_subscriber_move(&app->subscriber));
    }

    if (z_session_check(&app->session)) {
        zp_stop_read_task(z_session_loan(&app->session));
        zp_stop_lease_task(z_session_loan(&app->session));
        z_close(z_session_move(&app->session));
    }

    return 0;
}

/**
 * @brief      Callback for exiting the application.
 * @details    This function is called when user press back button.  We return VIEW_NONE to
 *            indicate that we want to exit the application.
 * @param      _context  The context - unused
 * @return     next view id
 */
static uint32_t zenoh_navigation_exit_callback(void* _context) {
    UNUSED(_context);
    return VIEW_NONE;
}

/**
 * @brief      Callback for returning to submenu.
 * @details    This function is called when user press back button.  We return VIEW_NONE to
 *            indicate that we want to navigate to the submenu.
 * @param      _context  The context - unused
 * @return     next view id
 */
static uint32_t zenoh_navigation_submenu_callback(void* _context) {
    UNUSED(_context);
    return ZenohViewSubmenu;
}

/**
 * @brief      Handle submenu item selection.
 * @details    This function is called when user selects an item from the submenu.
 * @param      context  The context - ZenohApp object.
 * @param      index     The ZenohSubmenuIndex item that was clicked.
 */
static void zenoh_submenu_callback(void* context, uint32_t index) {
    ZenohApp* app = (ZenohApp*)context;
    switch (index) {
        case ZenohSubmenuIndexConfigure:
            view_dispatcher_switch_to_view(app->view_dispatcher, ZenohViewConfigure);
            break;
        case ZenohSubmenuIndexMonitor:
            view_dispatcher_switch_to_view(app->view_dispatcher, ZenohViewMonitor);
            break;
        case ZenohSubmenuIndexAbout:
            view_dispatcher_switch_to_view(app->view_dispatcher, ZenohViewAbout);
            break;
        default:
            break;
    }

    if (index == ZenohSubmenuIndexMonitor) {
        zenoh_sub_start(app);
    } else {
        zenoh_sub_stop(app);
    }
}

/**
 * @brief      Callback for drawing the monitor screen.
 * @details    This function is called when the screen needs to be redrawn, like when the model gets updated.
 * @param      canvas  The canvas to draw on.
 * @param      model   The model - MyModel object.
 */
static void zenoh_view_monitor_draw_callback(Canvas* canvas, void* model) {
    (void)model;
    ZenohMonitorModel* my_model = (ZenohMonitorModel*)model;

    zp_mutex_lock(&g_samples_list_mutex);

    FuriString* xstr = furi_string_alloc();
    size_t i = 0;
    for (_z_list_t* it = g_samples_list; it; it = _z_list_tail(it)) {
        stored_sample_t* elem = _z_list_head(it);
        furi_string_printf(xstr, "%s: %s", elem->key, elem->val);
        canvas_draw_str(canvas, my_model->x, 10 + i++ * 12, furi_string_get_cstr(xstr));
    }
    furi_string_free(xstr);

    zp_mutex_unlock(&g_samples_list_mutex);
}

/**
 * @brief      Callback for timer elapsed.
 * @details    This function is called when the timer is elapsed.  We use this to queue a redraw event.
 * @param      context  The context - ZenohApp object.
 */
static void zenoh_view_monitor_timer_callback(void* context) {
    ZenohApp* app = (ZenohApp*)context;
    view_dispatcher_send_custom_event(app->view_dispatcher, ZenohEventIdRedrawScreen);
}

/**
 * @brief      Callback when the user starts the monitor screen.
 * @details    This function is called when the user enters the monitor screen.  We start a timer to
 *           redraw the screen periodically (so the random number is refreshed).
 * @param      context  The context - ZenohApp object.
 */
static void zenoh_view_monitor_enter_callback(void* context) {
    uint32_t period = furi_ms_to_ticks(200);
    ZenohApp* app = (ZenohApp*)context;
    furi_assert(app->timer == NULL);
    app->timer = furi_timer_alloc(zenoh_view_monitor_timer_callback, FuriTimerTypePeriodic, context);
    furi_timer_start(app->timer, period);
}

/**
 * @brief      Callback when the user exits the monitor screen.
 * @details    This function is called when the user exits the monitor screen.  We stop the timer.
 * @param      context  The context - ZenohApp object.
 */
static void zenoh_view_monitor_exit_callback(void* context) {
    ZenohApp* app = (ZenohApp*)context;
    furi_timer_stop(app->timer);
    furi_timer_free(app->timer);
    app->timer = NULL;
}

/**
 * @brief      Callback for custom events.
 * @details    This function is called when a custom event is sent to the view dispatcher.
 * @param      event    The event id - ZenohEventId value.
 * @param      context  The context - ZenohApp object.
 */
static bool zenoh_view_monitor_custom_event_callback(uint32_t event, void* context) {
    ZenohApp* app = (ZenohApp*)context;
    switch (event) {
        case ZenohEventIdRedrawScreen:
            // Redraw screen by passing true to last parameter of with_view_model.
            {
                bool redraw = true;
                with_view_model(
                    app->view_game, ZenohMonitorModel * _model, { UNUSED(_model); }, redraw);
                return true;
            }
        case ZenohEventIdOkPressed:
            // Process the OK button.
            return true;
        default:
            return false;
    }
}

/**
 * @brief      Callback for monitor screen input.
 * @details    This function is called when the user presses a button while on the monitor screen.
 * @param      event    The event - InputEvent object.
 * @param      context  The context - ZenohApp object.
 * @return     true if the event was handled, false otherwise.
 */
static bool zenoh_view_monitor_input_callback(InputEvent* event, void* context) {
    ZenohApp* app = (ZenohApp*)context;
    if (event->type == InputTypeShort) {
        if (event->key == InputKeyLeft) {
            // Left button clicked, reduce x coordinate.
            bool redraw = true;
            with_view_model(
                app->view_game, ZenohMonitorModel * model, { model->x += 10; }, redraw);
        } else if (event->key == InputKeyRight) {
            // Right button clicked, increase x coordinate.
            bool redraw = true;
            with_view_model(
                app->view_game, ZenohMonitorModel * model, { model->x -= 10; }, redraw);
        }
    } else if (event->type == InputTypePress) {
        if (event->key == InputKeyOk) {
            // We choose to send a custom event when user presses OK button.  zenoh_custom_event_callback will
            // handle our ZenohEventIdOkPressed event.  We could have just put the code from
            // zenoh_custom_event_callback here, it's a matter of preference.
            view_dispatcher_send_custom_event(app->view_dispatcher, ZenohEventIdOkPressed);
            return true;
        }
    }

    return false;
}

/**
 * @brief      Allocate the zenoh application.
 * @details    This function allocates the zenoh application resources.
 * @return     ZenohApp object.
 */
static ZenohApp* zenoh_app_alloc() {
    ZenohApp* app = (ZenohApp*)malloc(sizeof(ZenohApp));

    Gui* gui = furi_record_open(RECORD_GUI);

    app->view_dispatcher = view_dispatcher_alloc();
    view_dispatcher_enable_queue(app->view_dispatcher);
    view_dispatcher_attach_to_gui(app->view_dispatcher, gui, ViewDispatcherTypeFullscreen);
    view_dispatcher_set_event_callback_context(app->view_dispatcher, app);

    app->submenu = submenu_alloc();
    submenu_add_item(app->submenu, "Config", ZenohSubmenuIndexConfigure, zenoh_submenu_callback, app);
    submenu_add_item(app->submenu, "Monitor", ZenohSubmenuIndexMonitor, zenoh_submenu_callback, app);
    submenu_add_item(app->submenu, "About", ZenohSubmenuIndexAbout, zenoh_submenu_callback, app);
    view_set_previous_callback(submenu_get_view(app->submenu), zenoh_navigation_exit_callback);
    view_dispatcher_add_view(app->view_dispatcher, ZenohViewSubmenu, submenu_get_view(app->submenu));
    view_dispatcher_switch_to_view(app->view_dispatcher, ZenohViewSubmenu);

    app->variable_item_list_config = variable_item_list_alloc();
    variable_item_list_reset(app->variable_item_list_config);
    VariableItem* item = variable_item_list_add(app->variable_item_list_config, setting_1_config_label,
                                                COUNT_OF(setting_1_values), zenoh_setting_1_change, app);
    uint8_t baudrate = 6;
    variable_item_set_current_value_index(item, baudrate);
    variable_item_set_current_value_text(item, setting_1_names[baudrate]);

    view_set_previous_callback(variable_item_list_get_view(app->variable_item_list_config),
                               zenoh_navigation_submenu_callback);
    view_dispatcher_add_view(app->view_dispatcher, ZenohViewConfigure,
                             variable_item_list_get_view(app->variable_item_list_config));

    app->view_game = view_alloc();
    view_set_draw_callback(app->view_game, zenoh_view_monitor_draw_callback);
    view_set_input_callback(app->view_game, zenoh_view_monitor_input_callback);
    view_set_previous_callback(app->view_game, zenoh_navigation_submenu_callback);
    view_set_enter_callback(app->view_game, zenoh_view_monitor_enter_callback);
    view_set_exit_callback(app->view_game, zenoh_view_monitor_exit_callback);
    view_set_context(app->view_game, app);
    view_set_custom_callback(app->view_game, zenoh_view_monitor_custom_event_callback);
    view_allocate_model(app->view_game, ViewModelTypeLockFree, sizeof(ZenohMonitorModel));
    ZenohMonitorModel* model = view_get_model(app->view_game);
    model->baudrate = baudrate;
    model->x = 0;
    view_dispatcher_add_view(app->view_dispatcher, ZenohViewMonitor, app->view_game);

    app->widget_about = widget_alloc();
    widget_add_text_scroll_element(app->widget_about, 0, 0, 128, 64,
                                   "This is a sample zenoh sub,\nsee details https://zenoh.io");
    view_set_previous_callback(widget_get_view(app->widget_about), zenoh_navigation_submenu_callback);
    view_dispatcher_add_view(app->view_dispatcher, ZenohViewAbout, widget_get_view(app->widget_about));

    return app;
}

/**
 * @brief      Free the zenoh application.
 * @details    This function frees the zenoh application resources.
 * @param      app  The zenoh application object.
 */
static void zenoh_app_free(ZenohApp* app) {
    zenoh_sub_stop(app);

    view_dispatcher_remove_view(app->view_dispatcher, ZenohViewAbout);
    widget_free(app->widget_about);
    view_dispatcher_remove_view(app->view_dispatcher, ZenohViewMonitor);
    view_free(app->view_game);
    view_dispatcher_remove_view(app->view_dispatcher, ZenohViewConfigure);
    variable_item_list_free(app->variable_item_list_config);
    view_dispatcher_remove_view(app->view_dispatcher, ZenohViewSubmenu);
    submenu_free(app->submenu);
    view_dispatcher_free(app->view_dispatcher);
    furi_record_close(RECORD_GUI);

    free(app);
}

int32_t zenoh_sub_app(void* p) {
    UNUSED(p);

    zp_mutex_init(&g_samples_list_mutex);

    ZenohApp* app = zenoh_app_alloc();

    FURI_LOG_I(TAG, "start UI");
    view_dispatcher_run(app->view_dispatcher);

    FURI_LOG_I(TAG, "shutdown done");
    zenoh_app_free(app);
    zp_mutex_free(&g_samples_list_mutex);

    return 0;
}
